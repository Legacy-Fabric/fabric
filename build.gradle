plugins {
	id "java-library"
	id "eclipse"
	id "idea"
	id "maven-publish"
	id "fabric-loom" version "1.3.9" apply false
	id "legacy-looming" version "1.3.75" apply false
	id "com.diffplug.spotless" version "6.18.0"
	id "org.ajoberstar.grgit" version "3.1.1"
	id "me.modmuss50.mod-publish-plugin" version "0.4.5"
}

def ENV = System.getenv()

setVersion("${project.base_version}")
logger.lifecycle("Building Fabric: " + version)

def supportedVersions = [
    "1.12.2",
	"1.11.2",
	"1.10.2",
	"1.9.4",
	"1.8.9",
	"1.8",
	"1.7.10"
]
def supportedRanges = [
//    ["1.8", "1.8.9", false] // third parameter is whether or not to include snapshots in the range.
]

import net.fabricmc.loom.task.RemapJarTask
import org.apache.commons.codec.digest.DigestUtils
import org.kohsuke.github.GHReleaseBuilder
import net.legacyfabric.VersionHelper

static def getMCVersion(Project project) {
	def projectFullName = project.name

	if (!projectFullName.contains("_")) return "1.8.9"

	def mcVersion = projectFullName.split("_")[1]

	if (mcVersion == "common") return "1.8.9"

	return mcVersion
}

static def getProjectSimpleName(Project project) {
	def projectFullName = project.name

	if (!projectFullName.contains("_")) return projectFullName

	return projectFullName.split("_")[0]
}

def getProjectMavenName(project) {
	if (!(project instanceof Project)) project = rootProject.findProject("$project.name".toString())

	def simpleName = getProjectSimpleName(project)

	if (project.name.endsWith("_common")) {
		if (project.hasProperty("artifactSuffix")) {
			simpleName += project.artifactSuffix
		} else {
			simpleName += "-common"
		}
	}

	return simpleName
}



static def getMCRange(Project project) {
	def predicates = []

	if (project.hasProperty("minVersionIncluded") && project.hasProperty("maxVersionIncluded")
		&& project["minVersionIncluded"] == project["maxVersionIncluded"]
	) {
		predicates.add(project["maxVersionIncluded"])
	} else {
		if (project.hasProperty("minVersionIncluded")) {
			predicates.add(">=${VersionHelper.parseVersion(project["minVersionIncluded"]).friendlyString}")
		}

		if (project.hasProperty("minVersionExcluded")) {
			predicates.add(">${VersionHelper.parseVersion(project["minVersionExcluded"]).friendlyString}")
		}

		if (project.hasProperty("maxVersionIncluded")) {
			predicates.add("<=${VersionHelper.parseVersion(project["maxVersionIncluded"]).friendlyString}")
		}

		if (project.hasProperty("maxVersionExcluded")) {
			predicates.add("<${VersionHelper.parseVersion(project["maxVersionExcluded"]).friendlyString}")
		}

		if (predicates.isEmpty()) predicates.add("*")
	}

	return predicates.join(" ")
}

def getSubprojectVersion(Project project) {
	def version

	def nameParts = project.name.split("_")
	def projectName = nameParts[0]
	def mcVersion = nameParts[1]

	if (projectName == "legacyfabric-api") version = rootProject.version
	else version = rootProject[projectName + ".version"]

	if (mcVersion != "common") {
		version = version + "+" + mcVersion
	}

	if (projectName == "legacyfabric-api") return version

	if (grgit == null) {
		return version + "+nogit"
	}
	def latestCommits = grgit.log(paths: [rootProject.projectDir.toPath().relativize(project.projectDir.toPath()).toString()], maxCommits: 1)
	if (latestCommits.isEmpty()) {
		return version + "+uncommited"
	} else {
		return version + "+" + latestCommits.get(0).id.substring(0, 8) +
			DigestUtils.sha256Hex("${project.name}").substring(0, 2)
	}
}

def getBranch() {
	if (ENV.GIT_BRANCH) {
		def branch = ENV.GIT_BRANCH
		return branch.substring(branch.lastIndexOf("/") + 1)
	}

	if (grgit == null) {
		return "unknown"
	}

	def branch = grgit.branch.current().name
	return branch.substring(branch.lastIndexOf("/") + 1)
}

def static setupRepositories(RepositoryHandler repositories) {
	def ENV = System.getenv()
	if (ENV.MAVEN_PUBLISH_CREDENTIALS) {
		repositories.maven {
			url "https://repo.legacyfabric.net/repository/legacyfabric"
			credentials {
				username ENV.MAVEN_PUBLISH_CREDENTIALS.split(":")[0]
				password ENV.MAVEN_PUBLISH_CREDENTIALS.split(":")[1]
			}
			authentication {
				basic(BasicAuthentication)
			}
		}
	}
}

def moduleDependencies(Project project, List<String> projectNames) {
	def depNames = []

	def projectMCVersion = VersionHelper.parseVersion(getMCVersion(project))

	def isCommon = project.name.endsWith("_common")

	rootProject.subprojects {
		def subProjectName = getProjectSimpleName(it)

		if (projectNames.contains(subProjectName)) {
			def predicate = VersionHelper.parsePredicate(getMCRange(it))

			if (predicate.test(projectMCVersion)) depNames.add(it.name)
		}
	}

	if (!isCommon) {
		def commonProject = findProject(":${getProjectSimpleName(project)}_common")

		if (commonProject != null) {
			depNames.add(0, commonProject.name)
		}
	} else {
		depNames.removeIf { !it.endsWith("_common")}
	}

	def deps = depNames.iterator().collect { project.dependencies.project(path: ":$it", configuration: "namedElements") }
	def testOutputs = depNames.iterator().collect { findProject(":$it").sourceSets.testmod.output }

	project.dependencies {
		deps.each {
			api it
		}

		testOutputs.each {
			testmodImplementation it
		}
	}

	if (getProjectSimpleName(project) != "legacy-fabric-logger-api-v1") {
		deps.add(project.dependencies.project(path: ":legacy-fabric-logger-api-v1_common", configuration: "namedElements"))
	}

	// As we manually handle the maven artifacts, we need to also manually specify the deps.
	project.publishing {
		publications {
			mavenJava(MavenPublication) {
				if (getProjectSimpleName(project) == "legacyfabric-api") {
					artifactId = "legacy-fabric-api"
				}

				pom.withXml {
					def depsNode = asNode().appendNode("dependencies")
					deps.each {
						def depNode = depsNode.appendNode("dependency")
						depNode.appendNode("groupId", it.group)
						depNode.appendNode("artifactId", getProjectMavenName(it))
						depNode.appendNode("version", it.version)
						depNode.appendNode("scope", "compile")
					}
				}
			}
		}
	}
}

allprojects {
	group = "net.legacyfabric.legacy-fabric-api"

	apply plugin: "java-library"
	apply plugin: "checkstyle"
	apply plugin: "maven-publish"
	apply plugin: "signing"
	apply plugin: "fabric-loom"
	apply plugin: "legacy-looming"
	apply plugin: "com.diffplug.spotless"

	tasks.withType(GenerateModuleMetadata) {
		enabled = false
	}

	publishing {
		setupRepositories(repositories)
	}

	sourceCompatibility = JavaVersion.VERSION_1_8
	targetCompatibility = JavaVersion.VERSION_1_8

	tasks.withType(JavaCompile).configureEach {
		it.options.release = 8
	}

	java {
		// Must be added before the split source sets are setup.
		withSourcesJar()
	}

	sourceSets {
		testmod {
			compileClasspath += main.compileClasspath
			runtimeClasspath += main.runtimeClasspath
		}
	}

	System.out.println("Project: $it.name")

	if (it != rootProject) {
		setVersion(getSubprojectVersion(it))
	}

	def mcVersion = getMCVersion(it)
	String projectName = getProjectSimpleName(it)
	def hasTest = it.file("src/testmod").exists()

	loom {
		runs {
			"testModClient$mcVersion" {
				client()
				ideConfigGenerated projectName == "legacyfabric-api"
				name = "$mcVersion Testmod Client"
				source sourceSets.testmod

				if (VersionHelper.needUserProperties(mcVersion)) {
					programArgs "--userProperties", "{}"
				}
			}

			"testModServer$mcVersion" {
				server()
				ideConfigGenerated projectName == "legacyfabric-api"
				name = "$mcVersion Testmod Server"
				source sourceSets.testmod
			}
		}
	}

	allprojects.each { p ->
		if (p.file("src/main").exists()) {
			loom.mods.register(p.name) {
				sourceSet p.sourceSets.main
			}
		}

		if (p.file("src/testmod").exists()) {
			loom.mods.register(p.name + "-testmod") {
				sourceSet p.sourceSets.testmod
			}
		}
	}

	dependencies {
		minecraft "com.mojang:minecraft:${mcVersion}"
		mappings legacy.yarn(mcVersion, project.yarn_mappings_build)
		modImplementation "net.fabricmc:fabric-loader:${project.loader_version}"

		implementation "com.mojang:brigadier:1.0.17"

		testmodImplementation sourceSets.main.output
	}

	tasks.withType(ProcessResources).configureEach {
		inputs.property "version", project.version
		inputs.property "minecraft_version", getMCRange(project)

		filesMatching("fabric.mod.json") {
			expand "version": project.version, "minecraft_version": getMCRange(project)
		}
	}

	spotless {
		java {
			licenseHeaderFile(rootProject.file("HEADER"))
		}
	}

	checkstyle {
		configFile = rootProject.file("checkstyle.xml")
		toolVersion = "10.11.0"
	}

	tasks.withType(AbstractArchiveTask) {
		preserveFileTimestamps = false
		reproducibleFileOrder = true
	}

	if (hasTest) {
		task testmodJar(type: Jar) {
			from sourceSets.testmod.output
			destinationDirectory = new File(project.buildDir, "devlibs")
			archiveClassifier.set("testmod")
		}
	}

	[jar, sourcesJar].each {
		it.from(rootProject.file("LICENSE")) {
			rename { "${it}-${project.archivesBaseName}" }
		}
	}

	if (hasTest) {
		task remapTestmodJar(type: RemapJarTask, dependsOn: testmodJar) {
			input = testmodJar.archiveFile
			archiveClassifier.set("testmod")
			addNestedDependencies = false
		}
		build.dependsOn remapTestmodJar
	}
}

remapTestmodJar {
	def testModJarTasks = []

	subprojects {
		if (!it.file("src/testmod").exists()) return

		testModJarTasks += it.tasks.remapTestmodJar
	}

	nestedJars.setFrom(testModJarTasks)
	addNestedDependencies = true
}

javadoc {
	options {
		failOnError = false
		source = "8"
		encoding = "UTF-8"
		charSet = "UTF-8"
		memberLevel = JavadocMemberLevel.PACKAGE
		links(
			"https://guava.dev/releases/21.0/api/docs/",
			"https://asm.ow2.io/javadoc/",
			"https://docs.oracle.com/javase/8/docs/api/",
			"https://jenkins.liteloader.com/job/Mixin/javadoc/",
			"https://logging.apache.org/log4j/2.x/log4j-api/apidocs/"
			// Need to add minecraft jd publication etc once there is one available
		)
		// Disable the crazy super-strict doclint tool in Java 8
		addStringOption("Xdoclint:none", "-quiet")
	}

	allprojects.each {
		source(it.sourceSets.main.allJava.srcDirs)
	}

	classpath = sourceSets.main.compileClasspath
	include("**/api/**")
	failOnError false
}

task javadocJar(type: Jar) {
	dependsOn javadoc
	from javadoc.destinationDir
	//Set as `fatjavadoc` to prevent an ide form trying to use this javadoc, over using the modules javadoc
	archiveClassifier.set("fatjavadoc")
}

build.dependsOn javadocJar

subprojects {
	base.setArchivesName(getProjectMavenName(it))

	dependencies {
		testmodImplementation sourceSets.main.output

		if (getProjectSimpleName(project) != "legacy-fabric-logger-api-v1") {
			api project(path: ":legacy-fabric-logger-api-v1_common", configuration: "namedElements")
		}
	}

	publishing {
		publications {
			mavenJava(MavenPublication) {
				artifact(remapJar) {
					builtBy remapJar
				}
				artifact(remapSourcesJar) {
					builtBy remapSourcesJar
				}
			}
		}
	}

	// We manually handle the pom generation
	loom.disableDeprecatedPomGeneration(publishing.publications.mavenJava)

	javadoc.enabled = false

	def scriptPath = rootProject.file("${getProjectSimpleName(project)}/common.gradle")
	if (scriptPath.exists()) {
		apply from: rootProject.file("${getProjectSimpleName(project)}/common.gradle")
	}

	afterEvaluate {
		// Disable the gen sources task on sub projects
		genSourcesWithFernFlower.enabled = false
		genSourcesWithCfr.enabled = false

//		genClientOnlySourcesWithFernFlower.enabled = false
//		genClientOnlySourcesWithCfr.enabled = false
//		genCommonSourcesWithCfr.enabled = false
//		genCommonSourcesWithFernFlower.enabled = false
	}
}

publishing {
	publications {}
}

subprojects.each { if (it.file("src/main").exists()) remapJar.dependsOn("${it.path}:remapJar") }

sourceSets {
	testmod
}

dependencies {
	afterEvaluate {
		subprojects.each {
			if (getProjectSimpleName(it) == "legacyfabric-api") return

			if (it.file("src/main").exists()) api project(path: "${it.path}", configuration: "namedElements")
			if (it.file("src/testmod").exists()) testmodImplementation project("${it.path}").sourceSets.testmod.output
		}
	}
}

remapJar {
	afterEvaluate {
		subprojects.each {
			if (getProjectSimpleName(it) == "legacyfabric-api") return
			// Include the signed or none signed jar from the sub project.
			if (it.file("src/main").exists()) nestedJars.from project("${it.path}:").tasks.getByName("remapJar")
		}
	}
}

publishMods {
	file = remapJar.archiveFile
	changelog = providers.environmentVariable("CHANGELOG").getOrElse("A changelog can be found at https://github.com/Legacy-Fabric/fabric/commits")
	type = STABLE
	displayName = "Legacy Fabric API $project.version"
	modLoaders.add("fabric")
	dryRun = providers.environmentVariable("CURSE_API_KEY").getOrNull() == null

	curseforge {
		accessToken = providers.environmentVariable("CURSE_API_KEY")
		projectId = "400281"
		projectSlug = "legacy-fabric-api"

		minecraftVersions.addAll(supportedVersions)

		if (!supportedRanges.isEmpty()) {
			supportedRanges.each { range ->
				minecraftVersionRange {
					start = range[0]
					end = range[1]
				}
			}
		}
	}

	modrinth {
		accessToken = providers.environmentVariable("MODRINTH_TOKEN")
		projectId = "9CJED7xi"

		minecraftVersions.addAll(supportedVersions)

		if (!supportedRanges.isEmpty()) {
			supportedRanges.each { range ->
				minecraftVersionRange {
					start = range[0]
					end = range[1]

					includeSnapshots = range[2]
				}
			}
		}
	}

	github {
		accessToken = providers.environmentVariable("GITHUB_TOKEN")
		repository = providers.environmentVariable("GITHUB_REPOSITORY").getOrElse("LegacyFabric/dryrun")
		commitish = providers.environmentVariable("GITHUB_REF_NAME").getOrElse("dryrun")
	}

	discord {
		webhookUrl = providers.environmentVariable("DISCORD_WEBHOOK")

		dryRunWebhookUrl = ""

		username = "Legacy Fabric Bot"

		content = changelog.map { "# Legacy Fabric API $project.version has been released! \n" + it}
	}
}

// A task to ensure that the version being released has not already been released.
task checkVersion {
	doFirst {
		def xml = new URL("https://maven.legacyfabric.net/net/legacyfabric/legacy-fabric-api/legacy-fabric-api/maven-metadata.xml").text
		def metadata = new groovy.xml.XmlSlurper().parseText(xml)
		def versions = metadata.versioning.versions.version*.text()
		versions.each {
			if (it.startsWith(project.version + "+1.8.9")) {
				throw new RuntimeException("${project.version} has already been released!")
			}
		}
	}
}

tasks.publishMods.dependsOn checkVersion
publish.mustRunAfter checkVersion
