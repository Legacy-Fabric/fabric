plugins {
	id "java-library"
	id "eclipse"
	id "idea"
	id "maven-publish"
	id "fabric-loom" version "1.8.13" apply false
	id "legacy-looming" version "1.8.2" apply false
	id "com.diffplug.spotless" version "6.20.0"
	id "org.ajoberstar.grgit" version "5.2.2"
	id "me.modmuss50.mod-publish-plugin" version "0.4.5"
}

def ENV = System.getenv()

setVersion("${project.base_version}")
logger.lifecycle("Building Fabric: " + version)

def supportedVersions = [
    "1.12.2",
	"1.11.2",
	"1.10.2",
	"1.9.4",
	"1.8.9",
	"1.8",
	"1.7.10",
	"1.6.4"
]
def supportedRanges = [
//    ["1.8", "1.8.9", false] // third parameter is whether or not to include snapshots in the range.
]


import groovy.json.JsonSlurper
import net.fabricmc.loom.task.RemapJarTask
import net.legacyfabric.VersionHelper
import org.apache.commons.codec.digest.DigestUtils

static def parseProjectName(String name, Project project) {
	def parts = name.split("_")

	if (parts.length < 2) parts = [*parts, "1.8.9"]

	def (moduleName, mcVersion) = parts

	def isCommon = mcVersion == "common"

	def mavenName = moduleName.trim()

	if (isCommon) {
		mcVersion = "1.8.9"

		if (project != null && project.hasProperty("artifactSuffix")) {
			mavenName += project["artifactSuffix"]
		} else {
			mavenName += "-common"
		}
	}

	return [moduleName.trim(), mcVersion, isCommon, mavenName.trim()]
}

def projectInfoFromName(projectLike) {
	Project project
	if (!(projectLike instanceof Project)) {
		if (projectLike instanceof BasePluginExtension) {
			project = rootProject.findProject("${projectLike.archivesName.get()}".toString())
		} else {
			project = rootProject.findProject("$projectLike.name".toString())
		}
	}
	else project = projectLike

	return parseProjectName(project.name, project)
}

static def getMCRange(Project project) {
	def predicates = []

	if (project.hasProperty("minVersionIncluded") && project.hasProperty("maxVersionIncluded")
		&& project["minVersionIncluded"] == project["maxVersionIncluded"]
	) {
		predicates.add(project["maxVersionIncluded"])
	} else {
		if (project.hasProperty("minVersionIncluded")) {
			predicates.add(">=${VersionHelper.parseVersion(project["minVersionIncluded"]).friendlyString}")
		}

		if (project.hasProperty("minVersionExcluded")) {
			predicates.add(">${VersionHelper.parseVersion(project["minVersionExcluded"]).friendlyString}")
		}

		if (project.hasProperty("maxVersionIncluded")) {
			predicates.add("<=${VersionHelper.parseVersion(project["maxVersionIncluded"]).friendlyString}")
		}

		if (project.hasProperty("maxVersionExcluded")) {
			predicates.add("<${VersionHelper.parseVersion(project["maxVersionExcluded"]).friendlyString}")
		}

		if (predicates.isEmpty()) predicates.add("*")
	}

	return predicates.join(" ")
}

def getSubprojectVersion(Project project) {
	def version

	def (moduleName, mcVersion, isCommon) = projectInfoFromName(project)

	if (moduleName == "legacyfabric-api") version = rootProject.version
	else version = rootProject[moduleName + ".version"]

	if (!isCommon) {
		version = version + "+" + mcVersion
	}

	if (moduleName == "legacyfabric-api") return version

	if (grgit == null) {
		return version + "+nogit"
	}
	def latestCommits = grgit.log(paths: [rootProject.projectDir.toPath().relativize(project.projectDir.toPath()).toString()], maxCommits: 1)
	if (latestCommits.isEmpty()) {
		return version + "+uncommited"
	} else {
		return version + "+" + latestCommits.get(0).id.substring(0, 8) +
			DigestUtils.sha256Hex("${rootProject.version}").substring(0, 4)
	}
}

def getBranch() {
	if (ENV.GIT_BRANCH) {
		def branch = ENV.GIT_BRANCH
		return branch.substring(branch.lastIndexOf("/") + 1)
	}

	if (grgit == null) {
		return "unknown"
	}

	def branch = grgit.branch.current().name
	return branch.substring(branch.lastIndexOf("/") + 1)
}

def static setupRepositories(RepositoryHandler repositories) {
	def ENV = System.getenv()
	if (ENV.MAVEN_PUBLISH_CREDENTIALS) {
		repositories.maven {
			url "https://repo.legacyfabric.net/legacyfabric/"
			credentials {
				username ENV.MAVEN_PUBLISH_CREDENTIALS.split(":")[0]
				password ENV.MAVEN_PUBLISH_CREDENTIALS.split(":")[1]
			}
			authentication {
				basic(BasicAuthentication)
			}
		}
	}
}

def moduleDependencies(Project project, List<String> projectNames) {
	def depNames = []

	def (moduleName, mcVersion, isCommon) = projectInfoFromName(project)

	def projectMCVersion = VersionHelper.parseVersion(mcVersion)

	rootProject.subprojects {
		def (subModuleName) = projectInfoFromName(it)

		if (projectNames.contains(subModuleName)) {
			def predicate = VersionHelper.parsePredicate(getMCRange(it))

			if (predicate.test(projectMCVersion)) depNames.add(it.name)
		}
	}

	if (!isCommon) {
		def commonProject = findProject(":${moduleName}_common")

		if (commonProject != null) {
			def predicate = VersionHelper.parsePredicate(getMCRange(commonProject))
			if (predicate.test(projectMCVersion)) depNames.add(0, commonProject.name)
		}
	} else {
		depNames.removeIf { !it.endsWith("_common")}
	}

	def deps = depNames.iterator().collect { project.dependencies.project(path: ":$it", configuration: "namedElements") }
	def testOutputs = depNames.iterator().collect { findProject(":$it").sourceSets.testmod.output }

	project.dependencies {
		deps.each {
			api it
		}

		testOutputs.each {
			testmodImplementation it
		}
	}

	if (moduleName != "legacy-fabric-logger-api-v1") {
		deps.add(project.dependencies.project(path: ":legacy-fabric-logger-api-v1_common", configuration: "namedElements"))
	}

	// As we manually handle the maven artifacts, we need to also manually specify the deps.
	project.publishing {
		publications {
			mavenJava(MavenPublication) {
				pom.withXml {
					def depsNode = asNode().appendNode("dependencies")
					deps.each {
						def (_, _1, _2, mavenName) = projectInfoFromName(it)

						def depNode = depsNode.appendNode("dependency")
						depNode.appendNode("groupId", it.group)
						depNode.appendNode("artifactId", mavenName)
						depNode.appendNode("version", it.version)
						depNode.appendNode("scope", "compile")

						def exclusionsNode = depNode.appendNode("exclusions")
						def exclusionNode = exclusionsNode.appendNode("exclusion")
						exclusionNode.appendNode("groupId", "net.legacyfabric.legacy-fabric-api")
						exclusionNode.appendNode("artifactId", "*")
					}
				}
			}
		}
	}
}

allprojects {
	group = "net.legacyfabric.legacy-fabric-api"

	apply plugin: "java-library"
	apply plugin: "checkstyle"
	apply plugin: "maven-publish"
	apply plugin: "signing"
	apply plugin: "fabric-loom"
	apply plugin: "legacy-looming"
	apply plugin: "com.diffplug.spotless"

	tasks.withType(GenerateModuleMetadata) {
		enabled = false
	}

	publishing {
		setupRepositories(repositories)
	}

	tasks.withType(JavaCompile).configureEach {
		it.options.release = 8
	}

	java {
		sourceCompatibility = JavaVersion.VERSION_1_8
		targetCompatibility = JavaVersion.VERSION_1_8
		// Must be added before the split source sets are setup.
		withSourcesJar()
	}

	sourceSets {
		testmod {
			compileClasspath += main.compileClasspath
			runtimeClasspath += main.runtimeClasspath
		}
	}

	System.out.println("Project: $it.name")

	if (it != rootProject) {
		setVersion(getSubprojectVersion(it))
	}

	def (moduleName, mcVersion, _) = projectInfoFromName(it)
	def hasTest = it.file("src/testmod").exists()

	loom {
		mixin {
			useLegacyMixinAp = true
		}

		runs {
			"testModClient$mcVersion" {
				client()
				ideConfigGenerated moduleName == "legacyfabric-api"
				name = "$mcVersion Testmod Client"
				source sourceSets.testmod

				if (VersionHelper.needUserProperties(mcVersion)) {
					programArgs "--userProperties", "{}"
				}
			}

			"testModServer$mcVersion" {
				server()
				ideConfigGenerated moduleName == "legacyfabric-api"
				name = "$mcVersion Testmod Server"
				source sourceSets.testmod
			}
		}
	}

	allprojects.each { p ->
		if (p.file("src/main").exists()) {
			loom.mods.register(p.name) {
				sourceSet p.sourceSets.main
			}
		}

		if (p.file("src/testmod").exists()) {
			loom.mods.register(p.name + "-testmod") {
				sourceSet p.sourceSets.testmod
			}
		}
	}

	dependencies {
		minecraft "com.mojang:minecraft:${mcVersion}"
		mappings legacy.yarn(mcVersion, project.yarn_mappings_build)
		modImplementation "net.fabricmc:fabric-loader:${project.loader_version}"

		implementation "com.mojang:brigadier:1.0.17"

		testmodImplementation sourceSets.main.output
	}

	tasks.withType(ProcessResources).configureEach {
		inputs.property "version", project.version
		inputs.property "minecraft_version", getMCRange(project)

		filesMatching("fabric.mod.json") {
			expand "version": project.version, "minecraft_version": getMCRange(project)
		}
	}

	spotless {
		java {
			licenseHeaderFile(rootProject.file("HEADER"))
			removeUnusedImports()
			importOrder("java", "javax", "", "net.minecraft", "net.fabricmc", "net.legacyfabric")
			indentWithTabs()
			trimTrailingWhitespace()
			targetExclude('**/lib/sponge/*.java', '**/lib/sponge/**/*.java')
		}
		format("sponge", com.diffplug.gradle.spotless.JavaExtension) {
			licenseHeaderFile(rootProject.file("SPONGE_HEADER"))
			removeUnusedImports()
			importOrder("java", "javax", "", "net.minecraft", "net.fabricmc", "net.legacyfabric")
			indentWithTabs()
			trimTrailingWhitespace()
			target('**/lib/sponge/*.java', '**/lib/sponge/**/*.java')
		}
	}

	checkstyle {
		configFile = rootProject.file("checkstyle.xml")
		toolVersion = "10.11.0"
	}

	tasks.withType(AbstractArchiveTask) {
		preserveFileTimestamps = false
		reproducibleFileOrder = true
	}

	if (hasTest) {
		task testmodJar(type: Jar) {
			from sourceSets.testmod.output
			destinationDirectory = project.layout.buildDirectory.dir("devlibs")
			archiveClassifier.set("testmod")
		}
	}

	[jar, sourcesJar].each {
		it.from(rootProject.file("LICENSE")) {
			rename { "${it}-${project.base.archivesName}" }
		}
	}

	if (hasTest) {
		task remapTestmodJar(type: RemapJarTask, dependsOn: testmodJar) {
			input = testmodJar.archiveFile
			archiveClassifier.set("testmod")
			addNestedDependencies = false
		}
		build.dependsOn remapTestmodJar
	}
}

remapTestmodJar {
	def testModJarTasks = []

	subprojects {
		if (!it.file("src/testmod").exists()) return

		testModJarTasks += it.tasks.remapTestmodJar
	}

	nestedJars.setFrom(testModJarTasks)
	addNestedDependencies = true
}

javadoc {
	options {
		failOnError = false
		source = "8"
		encoding = "UTF-8"
		charSet = "UTF-8"
		memberLevel = JavadocMemberLevel.PACKAGE
		links(
			"https://guava.dev/releases/21.0/api/docs/",
			"https://asm.ow2.io/javadoc/",
			"https://docs.oracle.com/javase/8/docs/api/",
			"https://jenkins.liteloader.com/job/Mixin/javadoc/",
			"https://logging.apache.org/log4j/2.x/log4j-api/apidocs/"
			// Need to add minecraft jd publication etc once there is one available
		)
		// Disable the crazy super-strict doclint tool in Java 8
		addStringOption("Xdoclint:none", "-quiet")
	}

	allprojects.each {
		source(it.sourceSets.main.allJava.srcDirs)
	}

	classpath = sourceSets.main.compileClasspath
	include("**/api/**")
	failOnError false
}

task javadocJar(type: Jar) {
	dependsOn javadoc
	from javadoc.destinationDir
	//Set as `fatjavadoc` to prevent an ide form trying to use this javadoc, over using the modules javadoc
	archiveClassifier.set("fatjavadoc")
}

build.dependsOn javadocJar

def addPomMetadataInformation(Project project, MavenPom pom) {
	def modJsonFile = project.file("src/main/resources/fabric.mod.json")

	if (!modJsonFile.exists()) {
		modJsonFile = project.file("src/client/resources/fabric.mod.json")
	}

	def modJson = new JsonSlurper().parse(modJsonFile)
	pom.name = modJson.name
	pom.url = "https://github.com/Legacy-Fabric/fabric/tree/HEAD/${project.rootDir.relativePath(project.projectDir)}"
	pom.description = modJson.description
	pom.licenses {
		license {
			name = "Apache-2.0"
			url = "https://github.com/Legacy-Fabric/fabric/blob/HEAD/LICENSE"
		}
	}
	pom.developers {
		developer {
			name = "Legacy Fabric"
			url = "https://legacyfabric.net/"
		}
	}
	pom.scm {
		connection = "scm:git:https://github.com/Legacy-Fabric/fabric.git"
		url = "https://github.com/Legacy-Fabric/fabric"
		developerConnection = "scm:git:git@github.com:Legacy-Fabric/fabric.git"
	}
	pom.issueManagement {
		system = "GitHub"
		url = "https://github.com/Legacy-Fabric/fabric/issues"
	}
}

subprojects {
	def (moduleName, _, _1, mavenName) = projectInfoFromName(project)

	base {
		archivesName = mavenName
	}

	dependencies {
		testmodImplementation sourceSets.main.output

		if (moduleName != "legacy-fabric-logger-api-v1") {
			api project(path: ":legacy-fabric-logger-api-v1_common", configuration: "namedElements")
		}
	}

	publishing {
		publications {
			mavenJava(MavenPublication) {
				if (moduleName == "legacyfabric-api") {
					artifactId = "legacy-fabric-api"
				} else {
					artifactId = mavenName
				}

				pom {
					addPomMetadataInformation(project, pom)
				}

				artifact(remapJar) {
					builtBy remapJar
				}
				artifact(remapSourcesJar) {
					builtBy remapSourcesJar
				}
			}
		}
	}

	// We manually handle the pom generation
	loom.disableDeprecatedPomGeneration(publishing.publications.mavenJava)

	javadoc.enabled = false

	def scriptPath = rootProject.file("${moduleName}/common.gradle")
	if (scriptPath.exists()) {
		apply from: rootProject.file("${moduleName}/common.gradle")
	}

	afterEvaluate {
		// Disable the gen sources task on sub projects
		genSourcesWithFernFlower.enabled = false
		genSourcesWithCfr.enabled = false

//		genClientOnlySourcesWithFernFlower.enabled = false
//		genClientOnlySourcesWithCfr.enabled = false
//		genCommonSourcesWithCfr.enabled = false
//		genCommonSourcesWithFernFlower.enabled = false
	}
}

publishing {
	publications {}
}

subprojects {
	project.tasks.withType(PublishToMavenLocal).each {
		it.outputs.file("$rootProject.projectDir/temp")
	}
	project.tasks.withType(PublishToMavenRepository).each {
		it.outputs.file("$rootProject.projectDir/temp")
	}
}

subprojects.each { if (it.file("src/main").exists()) remapJar.dependsOn("${it.path}:remapJar") }

sourceSets {
	testmod
}

dependencies {
	afterEvaluate {
		subprojects.each {
			def (moduleName) = projectInfoFromName(it)

			if (moduleName == "legacyfabric-api") return

			if (it.file("src/main").exists()) api project(path: "${it.path}", configuration: "namedElements")
			if (it.file("src/testmod").exists()) testmodImplementation project("${it.path}").sourceSets.testmod.output
		}
	}
}

remapJar {
	afterEvaluate {
		subprojects.each {
			def (moduleName) = projectInfoFromName(it)

			if (moduleName == "legacyfabric-api") return
			// Include the signed or none signed jar from the sub project.
			if (it.file("src/main").exists()) nestedJars.from project("${it.path}:").tasks.getByName("remapJar")
		}
	}
}

publishMods {
	file = remapJar.archiveFile
	changelog = providers.environmentVariable("CHANGELOG").getOrElse("A changelog can be found at https://github.com/Legacy-Fabric/fabric/commits")
	type = STABLE
	displayName = "Legacy Fabric API $project.version"
	modLoaders.add("fabric")
	dryRun = providers.environmentVariable("CURSE_API_KEY").getOrNull() == null

	curseforge {
		accessToken = providers.environmentVariable("CURSE_API_KEY")
		projectId = "400281"
		projectSlug = "legacy-fabric-api"

		minecraftVersions.addAll(supportedVersions)

		if (!supportedRanges.isEmpty()) {
			supportedRanges.each { range ->
				minecraftVersionRange {
					start = range[0]
					end = range[1]
				}
			}
		}
	}

	modrinth {
		accessToken = providers.environmentVariable("MODRINTH_TOKEN")
		projectId = "9CJED7xi"

		minecraftVersions.addAll(supportedVersions)

		if (!supportedRanges.isEmpty()) {
			supportedRanges.each { range ->
				minecraftVersionRange {
					start = range[0]
					end = range[1]

					includeSnapshots = range[2]
				}
			}
		}
	}

	github {
		accessToken = providers.environmentVariable("GITHUB_TOKEN")
		repository = providers.environmentVariable("GITHUB_REPOSITORY").getOrElse("LegacyFabric/dryrun")
		commitish = providers.environmentVariable("GITHUB_REF_NAME").getOrElse("dryrun")
	}

	discord {
		webhookUrl = providers.environmentVariable("DISCORD_WEBHOOK")

		dryRunWebhookUrl = ""

		username = "Legacy Fabric Bot"

		content = changelog.map { "# Legacy Fabric API $project.version has been released! \n" + it}
	}
}

// A task to ensure that the version being released has not already been released.
task checkVersion {
	doFirst {
		def xml = new URL("https://maven.legacyfabric.net/net/legacyfabric/legacy-fabric-api/legacy-fabric-api/maven-metadata.xml").text
		def metadata = new groovy.xml.XmlSlurper().parseText(xml)
		def versions = metadata.versioning.versions.version*.text()
		versions.each {
			if (it.startsWith(project.version + "+1.8.9")) {
				throw new RuntimeException("${project.version} has already been released!")
			}
		}
	}
}

tasks.publishMods.dependsOn checkVersion
publish.mustRunAfter checkVersion
